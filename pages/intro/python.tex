\subsection{Python Basics}

\subsubsection{Pre-requisites}

At this point you should have installed the needed packages. You need also to feel comfortable with an IDE to edit code and an interactive command line. See previous sections for the details. Your work folder will be

\begin{verbatim}
lxmls-toolkit-student
\end{verbatim}

\noindent from there, start your interactive command line of choosing, e.g.,

\begin{verbatim}
jupyter-notebook
\end{verbatim}

\noindent and proceed with the following sections.

\subsubsection{Running Python code}

We will start by creating and running a dummy program in Python which simply
prints the ``Hello World!'' message to the standard output (this is usually the
first program you code when learning a new programming language). There are two
main ways in which you can run code in Python: 

\begin{description}
\item[From a file]--~~Create a file named \texttt{yourfile.py} and write your 
program in it, using the IDE of your choice, e.g., PyCharm:

\begin{python}
print('Hello World!')
\end{python}

After saving and closing the file, you can run your code by using the run
functionality in your IDE. If you wish to run from a command line instead do

\begin{verbatim}
python yourfile.py
\end{verbatim}

This will run the program and display the message ``Hello World!''. After 
that, the control will return to the command line or IDE.


\item[In the interactive command line]--~~Start your preferred interactive command line, e.g., 
Jupyter-notebook. There, you can run Python code
by simply writing it and pressing enter (ctr+enter in Jupyter).

\begin{python}
 In[]: print("Hello, World!")
Out[]: Hello, World!
\end{python}

However, you can also run Python code written into a file.

\begin{python}
 In[]: run ./yourfile.py
Out[]: Hello, World!
\end{python}
\end{description}

Keep in mind that you can easily switch between these two modes. You can
quickly test commands directly in the command line and, e.g., inspect variables.
Larger sections of code can be stored and run from files.

\subsubsection{Help and Documentation}

There are several ways to get help on Jupyter:

\begin{itemize}
\item Adding a question mark to the end of a function or variable and pressing
Enter brings up associated documentation. Unfortunately, not all packages are
well documented. Numpy and matplotlib are pleasant exceptions;
\item \code{help('if')} gets the online documentation for the \code{if} keyword;
\item \code{help()}, enters the help system.
\item When at the help system, type \code{q} to exit.
\end{itemize}

%\noindent For more information on IPython~\citep{PER-GRA:2007}, check the website: \url{http://ipython.scipy.org/moin/}

\subsection{Python by Example}

\subsubsection{Basic Math Operations}

Python supports all basic arithmetic operations, including exponentiation. For
example, the following code: \begin{python}
print(3 + 5)
print(3 - 5)
print(3 * 5)
print(3 / 5)
print(3 ** 5)
\end{python}

\noindent will produce the following output in Python 2:
\begin{python}
8
-2
15
0
243
\end{python}

\noindent and the following output in Python 3:
\begin{python}
8
-2
15
0.6
243
\end{python}

\textbf{Important}: Notice that in Python 2 division is always considered as integer division, hence the result
being 0 on the example above. To force a floating point division in Python 2 you can force
one of the operands to be a floating point number: \begin{python}
print(3 / 5.0)
0.6
\end{python}

For Python 3, the division is considered float point, so the operation (3 / 5) or (3 / 5.0) is always 0.6. 

Also, notice that the symbol \texttt{**} is used as exponentation operator, unlike other major languages which use the symbol \texttt{\^}. In fact, the \texttt{\^} symbol has a different meaning in Python (bitwise XOR) so, in the beginning, be sure to double-check your code if it uses exponentiation and it is giving unexpected results.

\subsubsection{Data Structures}

In Python, you can create lists of items with the following syntax:

\begin{python}
countries = ['Portugal','Spain','United Kingdom']
\end{python}

\noindent A string should be surrounded by either apostrophes (') or quotes (``). You can access a list with the following:

\begin{itemize}
 \item \code{len(L)}, which returns the number of items in L;
 \item \code{L[i]}, which returns the item at index $i$ (the first item has index 0);
 \item \code{L[i:j]}, which returns a new list, containing all the items between indexes $i$ and $j-1$, inclusively. 
\end{itemize}

\begin{exercise}
 Use L[i:j] to return the countries in the Iberian Peninsula.
\end{exercise}

\subsubsection{Loops and Indentation}

A loop allows a section of code to be repeated a certain number of times, until
a stop condition is reached. For instance, when the list you are iterating over has
reached its end or when a variable has reached a certain value (in this case,
you should not forget to update the value of that variable inside the code of
the loop). In Python you have \code{while} and \code{for} loop statements. The
following two example programs output exactly the same using both statements:
the even numbers from 2 to 8.

\begin{python}
i = 2
while i < 10:
  print(i)
  i += 2 
\end{python}

\begin{python}
for i in range(2,10,2):
    print(i)
\end{python}

You can copy and run this in Jupyter. Alternatively you can write this into your
\texttt{yourfile.py} file and run it. Do you notice something? It is possible
that the code did not act as expected or maybe an error message popped up. This
brings us to an important aspect of Python: \textbf{indentation}. Indentation
is the number of blank spaces at the leftmost of each command. This is how
Python differentiates between blocks of commands inside and outside of a
statement, e.g., \code{while} or \code{for}. All commands within a
statement have the same number of blank spaces at their leftmost. For instance,
consider the following code: 

\begin{python}
a=1
while a <= 3:
    print(a)
    a += 1
\end{python}

\noindent and its output:

\begin{python}
1
2
3
\end{python}


\begin{exercise}
Can you then predict the output of the following code?:

\begin{python}
a=1
while a <= 3:
    print(a)
a += 1
\end{python}

\end{exercise}

\noindent Bear in mind that indentation is often the main source of errors when starting to work with Python. Try to get used to it as quickly as possible. It is also recommendable to use a text editor that can display all characters e.g. blank space, tabs, since these characters can be visually similar but are considered different by Python. One of the most common mistakes by newcomers to Python is to have their files indented with spaces on some lines and with tabs on other lines. Visually it might appear that all lines have proper indentation, but you will get an \texttt{IndentationError} message if you try it. The recommended\footnote{The PEP8 document (\texttt{www.python.org/dev/peps/pep-0008}) is the official coding style guide for the Python language.} way is to use 4 spaces for each indentation level.

\subsubsection{Control Flow}

The \code{if} statement allows to control the flow of your program. The next program outputs a greeting that depends on the time of the day.

\begin{python}
hour = 16
if hour < 12:
    print('Good morning!')
elif hour >= 12 and hour < 20:
    print('Good afternoon!')
else:
    print('Good evening!')
\end{python}

\subsubsection{Functions}

A function is a block of code that can be reused to perform a similar action.
The following is a function in Python. 

\begin{python}
def greet(hour):
    if hour < 12:
        print('Good morning!')
    elif hour >= 12 and hour < 20:
        print('Good afternoon!')
    else:
        print('Good evening!')
\end{python}

You can write this command into Jupyter directly or write it into a file which you then run in Jupyter. Once you do this the function will be available for you to use. Call the function \code{greet} with different hours of the day (for example, type \texttt{greet(16)}) and see that the program will greet you accordingly.

\begin{exercise}
Note that the previous code allows the hour to be less than 0 or more than 24.  Change the code in order to indicate that the hour given as input is invalid.  Your output should be something like:

\begin{python}
greet(50)
Invalid hour: it should be between 0 and 24.
greet(-5)
Invalid hour: it should be between 0 and 24.
\end{python}

\end{exercise}

\subsubsection{Profiling}

If you are interested in checking the performance of your program, you can use the command \texttt{\%prun} in Jupyter. For example:

\begin{python}
def myfunction(x):
    ...

%prun myfunction(22)
\end{python}

The output of the \texttt{\%prun} command will show the following information
for each function that was called during the execution of your code:

\begin{itemize}
\item \texttt{ncalls}: The number of times this function was called. If this function was used recursively, the output will be two numbers; the first one counts the total function calls with recursions included, the second one excludes recursive calls.
\item \texttt{tottime}: Total time spent in this function, excluding the time spent in other functions called from within this function.
\item \texttt{percall}: Same as \texttt{tottime}, but divided by the number of calls.
\item \texttt{cumtime}: Same as \texttt{tottime}, but including the time spent in other functions called from within this function.
\item \texttt{percall}: Same as \texttt{cumtime}, but divided by the number of calls.
\item \texttt{filename:lineno(function)}: Tells you where this function was defined.
\end{itemize}

\subsubsection{Debugging in Python}

During the lab sessions, there will be situations in which we will use and extend modules that involve elaborated code and statements, like classes and nested functions. Although desirable, it should not be necessary for you to fully understand the whole code to carry out the exercises. It will suffice to understand the algorithm as explained in the theoretical part of the class and the local context of the part of the code where we will be working. For this to be possible is very important that you learn to use an IDE. 

An alternative to IDEs, that can also be useful for quick debugging in Jupyter, is the pdb module. This will stop the execution at a given point (called break-point) to get a quick glimpse of the variable structures and to inspect the execution flow of your program. The ipdb is an improved version of pdb that has to be installed separately. It provides additional functionalities like larger context windows, variable auto complete and colors. Unfortunately ipdb has some compatibility problems with Jupyter. We therefore recommend to use ipdb only in spartan configurations such as vim+ipdb as IDE.

\noindent In the following example, we use this module to inspect the \texttt{greet} function:

\begin{python}
def greet(hour):
    if hour < 12:
        print('Good morning!')
    elif hour >= 12 and hour < 20:
        print('Good afternoon!')
    else:
        import pdb; pdb.set_trace()
        print('Good evening!')
\end{python}

Load the new definition of the function by writing this code in a file or a Jupyter cell and running it. Now, if you try \texttt{greet(50)} the code execution should stop at the place where you located the break-point (that is, in the \texttt{print('Good evening!')} statement). You can now run new commands or inspect variables. For this purpose there are a number of commands you can use\footnotemark\footnotetext{The complete list can be found at \url{http://docs.python.org/library/pdb.html}}, but we provide here a short table with the most useful ones: 

\begin{table}[!h]
\begin{center}
\begin{tabular}{|l|l|}
\hline
(h)elp           & Starts the help menu\\
(p)rint          & Prints a variable\\
(p)retty(p)rint	 & Prints a variable, with line break (useful for lists)\\
\hline
(n)ext line      & Jumps to next line\\ 
(s)tep           & Jumps inside of the function we stopped at\\
c(ont(inue))     & Continues execution until finding breakpoint or finishing\\
(r)eturn         & Continues execution until current function returns\\
b(reak) n        & Sets a breakpoint in in line n\\
b(reak) n, condition  & Sets a conditional breakpoint in in line n\\
\hline
l(ist) [n], [m]  & Prints 11 lines around current line. Optionally starting in line n or between lines n, m\\
w(here)          & Shows which function called the function we are in, and upwards (stack)\\
u(p)             & Goes one level up the stack (frame of the function that called the function we are on)\\
d(down)          & Goes one level down the stack\\
\hline
\textit{blank}          & Repeat the last command\\ 
\textit{expression}     & Executes the python expression as if it was in current frame\\
\hline
\end{tabular}
\end{center}
\caption{\label{tb::pdbbasiccommands}Basic pdb/ipdb commands, parentheses indicates abbreviation}
\end{table}

%\footnotetext{\textit{expression} can not by any of the previous words reserved for commands. Use p expression for those cases.}
\noindent Getting back to our example, we can type n(ext) once to execute the line we
stopped at

\begin{python}
pdb> n
> ./lxmls-toolkit/yourfile.py(8)greet()
      7                 import pdb; pdb.set_trace()
----> 8                 print('Good evening!') 
\end{python}

\noindent Now we can inspect the variable \texttt{hour} using the p(retty)p(rint) option

\begin{python}
pdb> pp hour
50
\end{python}

From here we could keep advancing with the n(ext) option or set a b(reak) point
and type c(ontinue) to jump to a new position. We could also execute any python
expression which is valid in the current frame (the function we stopped at).
This is particularly useful to find out why code crashes, as we can try
different alternatives without the need to restart the code again.

\subsection{Exceptions}

Occasionally, a syntactically correct code statement may produce an error when
an attempt is made to execute it. These kind of errors are called
\textit{exceptions} in Python. For example, try executing the following:

\begin{python}
10/0
\end{python}

A \textit{ZeroDivisionError} exception was raised, and no output was returned.
Exceptions can also be forced to occur by the programmer, with customized error
messages \footnotemark\footnotetext{For a complete list of built-in exceptions, see
\url{http://docs.python.org/3/library/exceptions.html}}.

\begin{python}
raise ValueError("Invalid input value.")
\end{python}

\begin{exercise}
Rewrite the code in Exercise 0.3 in order to raise a ValueError exception when
the hour is less than 0 or more than 24.  \end{exercise}

\noindent Handling of exceptions is made with the \textit{try} statement:

\begin{python}
while True:
    try:
        x = int(input("Please enter a number: "))
        break
    except ValueError:
        print("Oops! That was no valid number. Try again...")
\end{python}

It works by first executing the \textit{try} clause. If no exception occurs, the \textit{except} clause is skipped; if an exception does occur, and if its type matches the exception named in the \textit{except} keyword, the except clause is executed; otherwise, the exception is raised and execution is aborted (if it is not caught by outer \textit{try} statements).


\subsubsection{Extending basic Functionalities with Modules}

In Python you can load new functionalities into the language by using the
\code{import}, \code{from} and \code{as} keywords. For example, we can load the
numpy module as

\begin{python}
import numpy as np
\end{python}

\noindent Then we can run the following on the Jupyter command line:

\begin{python}
np.var?
np.random.normal?
\end{python}

The import will make the numpy tools available through the alias \code{np}.  This shorter alias prevents the code from getting too long if we load lots of modules. The first command will display the help for the method \code{numpy.var} using the previously commented symbol \code{?}. Note that in order to display the help you need the full name of the function including the module name or alias. Modules have also submodules that can be accessed the same way, as shown in the second example.

\subsubsection{Organizing your Code with your own modules}

Creating you own modules is extremely simple. you can for example create the
file in your work directory

\begin{verbatim}
my_tools.py
\end{verbatim}

\noindent and store there the following code 

\begin{python}
def my_print(input):
    print(input)
\end{python}

From Jupyter you can now import and use this tool as

\begin{python}
import my_tools
my_tools.my_print("This works!") 
\end{python}

\textbf{Important}: When you modify a module, you need to reload the notebook page for the changes to take effect. Autoreload is set by default in the schools notebooks.

\noindent for the latter. Other ways of importing one or all the tools from a module are

\begin{python}
from my_tools import my_print  # my_print directly accesible in code
from my_tools import *         # will make all functions in my_tools accessible
\end{python}

\noindent However, this makes reloading the module more complicated. You can also store tools ind different folders. For example, if you store the previous
example in the folder

\begin{verbatim}
day0_tools
\end{verbatim}

\noindent and store inside an empty file called  

\begin{verbatim}
__init__.py
\end{verbatim}

\noindent then the following import will work

\begin{python}
import day0_tools.my_tools
\end{python}


\subsection{Matplotlib -- Plotting in Python}

Matplotlib\footnote{\url{http://matplotlib.org/}} is a plotting library for Python. It supports \textsc{2d} and \textsc{3d} plots of various forms. It can show them interactively or save them to a file (several output formats are supported).

\begin{python}
import numpy as np
import matplotlib.pyplot as plt

X = np.linspace(-4, 4, 1000)

plt.plot(X, X**2*np.cos(X**2))
plt.savefig("simple.pdf")
\end{python}

\begin{exercise}
Try running the following on Jupyter, which will introduce you to some of the basic numeric and plotting operations.

\begin{python}
# This will import the numpy library
# and give it the np abbreviation
import numpy as np

# This will import the plotting library
import matplotlib.pyplot as plt

# Linspace will return 1000 points,
# evenly spaced between -4 and +4
X = np.linspace(-4, 4, 1000)

# Y[i] = X[i]**2
Y = X**2

# Plot using a red line ('r')
plt.plot(X, Y, 'r')

# arange returns integers ranging from -4 to +4
# (the upper argument is excluded!)
Ints = np.arange(-4,5)

# We plot these on top of the previous plot
# using blue circles (o means a little circle)
plt.plot(Ints, Ints**2, 'bo')

# You may notice that the plot is tight around the line
# Set the display limits to see better
plt.xlim(-4.5,4.5)
plt.ylim(-1,17)
plt.show()
\end{python}
\end{exercise}

\subsection{Numpy -- Scientific Computing with Python}

Numpy\footnote{\url{http://www.numpy.org/}} is a library for scientific computing with Python.

\subsubsection{Multidimensional Arrays}

The main object of numpy is the multidimensional array. A multidimensional array is a table with all elements of the same type and can have several dimensions. Numpy provides various functions to access and manipulate multidimensional arrays. In one dimensional arrays, you can index, slice, and iterate as you can with lists. In a two dimensional array M, you can perform these operations along several dimensions.

\begin{itemize}
 \item M[i,j], to access the item in the $i^{th}$ row and $j^{th}$ column; 
 \item M[i:j,:], to get the all the rows between the $i^{th}$ and $j-1^{th}$;
 \item M[:,i], to get the $i^{th}$ column of M.
\end{itemize}

\noindent Again, as it happened with the lists, the first item of every column and every row has index 0.

\begin{python}
import numpy as np
A = np.array([
    [1,2,3],
    [2,3,4],
    [4,5,6]])

A[0,:] # This is [1,2,3]
A[0] # This is [1,2,3] as well

A[:,0] # this is [1,2,4]

A[1:,0] # This is [ 2, 4 ]. Why?
        # Because it is the same as A[1:n,0] where n is the size of the array.
\end{python}

\subsubsection{Mathematical Operations}

There are many helpful functions in numpy. For basic mathematical operations, we have \code{np.log}, \code{np.exp}, \code{np.cos},\ldots with the expected meaning. These operate both on single arguments and on arrays (where they will behave element wise).

\begin{python}
import matplotlib.pyplot as plt
import numpy as np

X = np.linspace(0, 4 * np.pi, 1000)
C = np.cos(X)
S = np.sin(X)

plt.plot(X, C)
plt.plot(X, S)
\end{python}

Other functions take a whole array and compute a single value from it. For example, \code{np.sum}, \code{np.mean},\ldots These are available as both free functions and as methods on arrays.

\begin{python}
import numpy as np

A = np.arange(100)

# These two lines do exactly the same thing
print(np.mean(A))
print(A.mean())

C = np.cos(A)
print(C.ptp())
\end{python}

\begin{exercise}
Run the above example and lookup the \code{ptp} function/method (use the \texttt{?} functionality in Jupyter).
\end{exercise}


\begin{exercise}
Consider the following approximation to compute an integral

\[
\int_0^{1} f(x)dx \approx \sum_{i = 0}^{999} \frac{f(i/1000)}{1000}.
\]

Use numpy to implement this for $f(x) = x^2$. You should not need to use any loops. Note that integer division in Python 2.x returns the floor division (use floats -- e.g. $5.0/2.0$ -- to obtain rationals). The exact value is $1/3$. How close is the approximation?
\end{exercise}
